在之前的介绍中，我们都是利用正交投影去观察我们的图形，这就意味这：
人得眼睛是在Z轴正方向向内（Z轴负方向）看没有任何偏移。而且此时我们看到的空间属于正方体的空间，
最前面和最后面的东西的大小由坐标来决定。这样是真实的，但是却不符合人眼所看到的。
有一首诗说道：

> 横看成岭侧成峰 远景高低各不同

正是因为透视，所以我们才会在相同的物体上看到不同的景色。
怎么在我们所绘制的内容中使用透视呢？
我们先从一张图说起：

![perspective](https://cloud.githubusercontent.com/assets/4397546/10448537/17470b28-71c0-11e5-8fb4-769a1cdf3c87.png)

假设我们人眼在EYE这个地方，往Z轴负方向看，离眼睛近的那条边的y的长度是[-1,1]，而离眼睛远的那条边的长度也是[-1,1]，这显然在透视模型中是不可能的。
所以我们要做一些变化，让我们的y根据z的不同来改变，所以这里我们假设有一个方法`f(z)`能够做到这一点，所以:`f(z) = y`,怎么来计算呢，假设我们知道FOV（机器所观察到的角度），在上图中，`y/-z = tan(fov/2)`;x同理`x/-z = tan(fov/2)`;
我们令`f = 1/tan(fov/2)`，故有`y = 1/f * -z -> y = -z/f`;

之前介绍的方块都是在[-1,1]之间，假设我们有一个特别小的z = -10，那么，计算出来的x或者y的值也会大于1，这显然不符合我们的显示内容，
所以接下来我们还需要进行一个转换，将y的坐标转换成[-1,1]之间的。`yClip = yCamera * f / z`;
也就是说在屏幕域(-1,1)之间投影出来的y的距离，等于cameraY的距离比上y的距离。因为y的距离是fov在z点的总高度，所以此式成立。
求出了y怎么求x呢，其实在这里我们的x、y之间存在着一种关系：我们能够获得到屏幕的宽度和高度，这个比例应该和我们渲染出来的物体一致，所以`x = y * aspect`;
z的坐标和x y 并不相关，在这里我们假设物体和人眼之间的关系为`A/z + B = z0`,其中A，B为参数，`z0`为屏幕域（-1，1）的值，而z为设置的初始值。
将`z=near,z0=1`,`z=far,z0=1`带入，得到`A = (near+far)/(near - far)`,`B = near*far*2 / (near - far)`;
又在WEBGL中，W切量的值总是要去除以`(X,Y,Z)`的，而在X,Y,Z分量中，我们都是除以了Z，故W = - Z;

有了以上知识，我们来构建我们的矩阵来将正交投影转为透视视图,这里有四个参数分别得到fov，屏幕比例，最近能够看到的点，最远能够看到的点。

```js
function perspective(fov,aspect,near,far){
	var f = Math.tan(Math.PI/2 - fov/2);
	var rangeInv = 1.0 / (near - far); 

	return [
	//  x         y  	z  						 w 
		f/aspect, 0, 	0, 						 0,
		0,        f, 	0, 						 0,
		0,        0, 	(near + far)*rangeInv,  -1,
		0,        0, 	near*far* rangeInv *2,   0
	];
}

```
在shader中，用这个矩阵去乘以物体的转换矩阵，得到最终在视野中的状态。

 
